var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
class AstroElementRegistry {
  constructor(options) {
    this.cache = new Map();
    this.candidates = options.candidates;
  }
  find(tagName) {
    for (let [module, importSpecifier] of this.candidates) {
      if (module && typeof module.tagName === "string") {
        if (module.tagName === tagName) {
          return importSpecifier;
        }
      }
    }
  }
  findCached(tagName) {
    if (this.cache.has(tagName)) {
      return this.cache.get(tagName);
    }
    let specifier = this.find(tagName);
    if (specifier) {
      this.cache.set(tagName, specifier);
    }
    return specifier;
  }
  astroComponentArgs(tagName, metadata) {
    const specifier = this.findCached(tagName);
    const outMeta = __spreadProps(__spreadValues({}, metadata), {
      componentUrl: specifier || metadata.componentUrl
    });
    return [tagName, outMeta];
  }
}

export { AstroElementRegistry };
