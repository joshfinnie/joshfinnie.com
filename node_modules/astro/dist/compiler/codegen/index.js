var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import eslexer from "es-module-lexer";
import esbuild from "esbuild";
import path from "path";
import astroParser from "@astrojs/parser";
import {walk, asyncWalk} from "estree-walker";
import _babelGenerator from "@babel/generator";
import babelParser from "@babel/parser";
import {codeFrameColumns} from "@babel/code-frame";
import * as babelTraverse from "@babel/traverse";
import {error, warn, parseError} from "../../logger.js";
import {yellow} from "kleur/colors";
import {isComponentTag, isCustomElementTag, positionAt} from "../utils.js";
import {warnIfRelativeStringLiteral} from "./utils.js";
import {renderMarkdown} from "@astrojs/markdown-support";
import {camelCase} from "camel-case";
import {transform} from "../transform/index.js";
import {PRISM_IMPORT} from "../transform/prism.js";
import {nodeBuiltinsSet} from "../../node_builtins.js";
import {readFileSync} from "fs";
import {fileURLToPath, pathToFileURL} from "url";
const {parse, FEATURE_CUSTOM_ELEMENT} = astroParser;
const traverse = babelTraverse.default.default;
const babelGenerator = _babelGenerator.default;
const {transformSync} = esbuild;
const hydrationDirectives = new Set(["client:load", "client:idle", "client:visible", "client:media", "client:only"]);
function findHydrationAttributes(attrs) {
  let method;
  let value;
  for (const [key, val] of Object.entries(attrs)) {
    if (hydrationDirectives.has(key)) {
      method = key.slice(7);
      value = val === "true" ? void 0 : val;
    }
  }
  return {method, value};
}
async function getAttributes(nodeName, attrs, state, compileOptions) {
  const isPage = state.filename.startsWith(fileURLToPath(compileOptions.astroConfig.pages));
  let result = {};
  for (const attr of attrs) {
    if (attr.type === "Spread") {
      const code = await compileExpression(attr.expression, state, compileOptions);
      if (code) {
        result[`...(${code})`] = "";
      }
      continue;
    }
    if (attr.value === true) {
      result[attr.name] = JSON.stringify(attr.value);
      continue;
    }
    if (attr.value === false || attr.value === void 0) {
      continue;
    }
    if (attr.value.length === 0) {
      result[attr.name] = '""';
      continue;
    }
    if (attr.value.length > 1) {
      result[attr.name] = "(" + attr.value.map((v) => {
        if (v.content) {
          return v.content;
        } else {
          return JSON.stringify(getTextFromAttribute(v));
        }
      }).join("+") + ")";
      continue;
    }
    const val = attr.value[0];
    if (!val) {
      result[attr.name] = "(" + val + ")";
      continue;
    }
    switch (val.type) {
      case "MustacheTag": {
        const code = await compileExpression(val.expression, state, compileOptions);
        if (code) {
          result[attr.name] = "(" + code + ")";
        }
        continue;
      }
      case "Text": {
        let text = getTextFromAttribute(val);
        if (!isPage) {
          warnIfRelativeStringLiteral(compileOptions.logging, nodeName, attr, text);
        }
        result[attr.name] = JSON.stringify(text);
        continue;
      }
      case "AttributeShorthand":
        result[attr.name] = "(" + attr.name + ")";
        continue;
      default:
        throw new Error(`UNKNOWN: ${val.type}`);
    }
  }
  return result;
}
function getTextFromAttribute(attr) {
  switch (attr.type) {
    case "Text": {
      if (attr.raw !== void 0) {
        return attr.raw;
      }
      if (attr.data !== void 0) {
        return attr.data;
      }
      break;
    }
    case "MustacheTag": {
      return attr.expression.codeChunks[0];
    }
  }
  throw new Error(`Unknown attribute type ${attr.type}`);
}
function generateAttributes(attrs) {
  let result = "{";
  for (const [key, val] of Object.entries(attrs)) {
    if (hydrationDirectives.has(key)) {
      continue;
    } else if (key.startsWith("...")) {
      result += key + ",";
    } else {
      result += JSON.stringify(key) + ":" + val + ",";
    }
  }
  result += `[__astroContext]:props[__astroContext]`;
  return result + "}";
}
function getComponentUrl(astroConfig, url, parentUrl) {
  const componentExt = path.extname(url);
  const ext = PlainExtensions.has(componentExt) ? ".js" : `${componentExt}.js`;
  const outUrl = new URL(url, parentUrl);
  return "/_astro/" + outUrl.href.replace(astroConfig.projectRoot.href, "").replace(/\.[^.]+$/, ext);
}
const PlainExtensions = new Set([".js", ".jsx", ".ts", ".tsx"]);
function getComponentWrapper(_name, hydration, {url, importSpecifier}, opts) {
  const {astroConfig, filename, compileOptions} = opts;
  let name = _name;
  let method = hydration.method;
  if (name.indexOf(":") > 0) {
    const [legacyName, legacyMethod] = _name.split(":");
    name = legacyName;
    method = legacyMethod;
    const shortname = path.posix.relative(compileOptions.astroConfig.projectRoot.pathname, filename);
    warn(compileOptions.logging, shortname, yellow(`Deprecation warning: Partial hydration now uses a directive syntax. Please update to "<${name} client:${method} />"`));
  }
  if (isCustomElementTag(_name)) {
    return {
      wrapper: `__astro_component(...__astro_element_registry.astroComponentArgs("${name}", ${JSON.stringify({hydrate: method, displayName: _name})}))`,
      wrapperImports: [
        `import {AstroElementRegistry} from 'astro/dist/internal/element-registry.js';`,
        `import {__astro_component} from 'astro/dist/internal/__astro_component.js';`
      ]
    };
  } else {
    const getComponentExport = () => {
      switch (importSpecifier.type) {
        case "ImportDefaultSpecifier":
          return {value: "default"};
        case "ImportSpecifier": {
          if (importSpecifier.imported.type === "Identifier") {
            return {value: importSpecifier.imported.name};
          }
          return {value: importSpecifier.imported.value};
        }
        case "ImportNamespaceSpecifier": {
          const [_, value] = _name.split(".");
          return {value};
        }
      }
    };
    let metadata = "";
    if (method) {
      const componentUrl = getComponentUrl(astroConfig, url, pathToFileURL(filename));
      const componentExport = getComponentExport();
      metadata = `{ hydrate: "${method}", displayName: "${name}", componentUrl: "${componentUrl}", componentExport: ${JSON.stringify(componentExport)}, value: ${hydration.value || "null"} }`;
      if (method === "only") {
        name = "Fragment";
      }
    } else {
      metadata = `{ hydrate: undefined, displayName: "${name}", value: ${hydration.value || "null"} }`;
    }
    return {
      wrapper: `__astro_component(${name}, ${metadata})`,
      wrapperImports: [`import {__astro_component} from 'astro/dist/internal/__astro_component.js';`]
    };
  }
}
async function compileExpression(node, state, compileOptions) {
  var _a;
  const children = await Promise.all(((_a = node.children) != null ? _a : []).map((child) => compileHtml(child, state, compileOptions)));
  let raw = "";
  let nextChildIndex = 0;
  for (const chunk of node.codeChunks) {
    raw += chunk;
    if (nextChildIndex < children.length) {
      raw += children[nextChildIndex++];
    }
  }
  const location = {start: node.start, end: node.end};
  let code = transpileExpressionSafe("(" + raw + ")", {state, compileOptions, location});
  if (code === null)
    throw new Error(`Unable to compile expression`);
  code = code.trim().replace(/\;$/, "");
  return code;
}
function transpileExpressionSafe(raw, {state, compileOptions, location}) {
  try {
    let {code} = transformSync(raw, {
      loader: "tsx",
      jsxFactory: "h",
      jsxFragment: "Fragment",
      charset: "utf8"
    });
    return code;
  } catch ({errors}) {
    const err = new Error();
    const e = errors[0];
    err.filename = state.filename;
    const text = readFileSync(state.filename).toString();
    const start = positionAt(location.start, text);
    start.line += e.location.line;
    start.character += e.location.column + 1;
    err.start = {line: start.line, column: start.character};
    const end = __spreadValues({}, start);
    end.character += e.location.length;
    const frame = codeFrameColumns(text, {
      start: {line: start.line, column: start.character},
      end: {line: end.line, column: end.character}
    });
    err.frame = frame;
    err.message = e.text;
    parseError(compileOptions.logging, err);
    return null;
  }
}
function compileModule(ast, module, state, compileOptions) {
  var _a, _b, _c;
  const {astroConfig} = compileOptions;
  const {filename} = state;
  const componentImports = [];
  const componentProps = [];
  const componentExports = [];
  let script = "";
  let propsStatement = "";
  let getStaticPaths = "";
  if (module) {
    const parseOptions = {
      sourceType: "module",
      plugins: ["jsx", "typescript", "topLevelAwait", "throwExpressions"]
    };
    let parseResult;
    try {
      parseResult = babelParser.parse(module.content, parseOptions);
    } catch (err) {
      const location2 = {start: err.loc};
      const frame = codeFrameColumns(module.content, location2);
      err.frame = frame;
      err.filename = state.filename;
      err.start = err.loc;
      throw err;
    }
    if (/Astro\s*\.\s*fetchContent/.test(module.content)) {
      state.importStatements.add(`import {fetchContent} from 'astro/dist/internal/fetch-content.js';
`);
      traverse(parseResult, {
        enter({node}) {
          if (node.type !== "CallExpression" || node.callee.type !== "MemberExpression" || node.callee.object.name !== "Astro" || node.callee.property.name !== "fetchContent") {
            return;
          }
          if (node.arguments[0].type !== "StringLiteral") {
            throw new Error(`[Astro.fetchContent] Only string literals allowed, ex: \`Astro.fetchContent('./post/*.md')\`
  ${state.filename}`);
          }
          node.arguments = [
            {
              type: "CallExpression",
              callee: {
                type: "MemberExpression",
                object: {type: "MetaProperty", meta: {type: "Identifier", name: "import"}, property: {type: "Identifier", name: "meta"}},
                property: {type: "Identifier", name: "globEager"},
                computed: false
              },
              arguments: node.arguments
            }
          ];
        }
      });
    }
    const program = parseResult.program;
    const {body} = program;
    let i = body.length;
    while (--i >= 0) {
      const node = body[i];
      switch (node.type) {
        case "ExportNamedDeclaration": {
          if (!node.declaration)
            break;
          if (node.declaration.type === "VariableDeclaration") {
            const declaration = node.declaration.declarations[0];
            if (declaration.id.name === "__layout" || declaration.id.name === "__content") {
              componentExports.push(node);
            } else {
              componentProps.push(declaration);
            }
          } else if (node.declaration.type === "FunctionDeclaration") {
            if (!node.declaration.id || node.declaration.id.name !== "getStaticPaths")
              break;
            getStaticPaths = babelGenerator(node).code;
          }
          body.splice(i, 1);
          break;
        }
        case "FunctionDeclaration": {
          if ((_a = node.id) == null ? void 0 : _a.name) {
            state.declarations.add((_b = node.id) == null ? void 0 : _b.name);
          }
          break;
        }
        case "ImportDeclaration": {
          componentImports.push(node);
          body.splice(i, 1);
          break;
        }
        case "VariableDeclaration": {
          for (const declaration of node.declarations) {
            if (declaration.id.type === "Identifier") {
              state.declarations.add(declaration.id.name);
            }
          }
          break;
        }
      }
    }
    for (const componentImport of componentImports) {
      const importUrl = componentImport.source.value;
      if (nodeBuiltinsSet.has(importUrl)) {
        throw new Error(`Node builtins must be prefixed with 'node:'. Use node:${importUrl} instead.`);
      }
      for (const specifier of componentImport.specifiers) {
        const componentName = specifier.local.name;
        state.components.set(componentName, {
          importSpecifier: specifier,
          url: importUrl
        });
        if (!state.componentImports.has(componentName)) {
          state.componentImports.set(componentName, []);
        }
        const {start: start2, end: end2} = componentImport;
        (_c = state.componentImports.get(componentName)) == null ? void 0 : _c.push(module.content.slice(start2 || void 0, end2 || void 0));
      }
      const {start, end} = componentImport;
      if (ast.meta.features & FEATURE_CUSTOM_ELEMENT && componentImport.specifiers.length === 0) {
        const moduleImportName = camelCase(importUrl + "Module");
        state.importStatements.add(`import * as ${moduleImportName} from '${importUrl}';
`);
        state.customElementCandidates.set(moduleImportName, getComponentUrl(astroConfig, importUrl, pathToFileURL(filename)));
      } else {
        state.importStatements.add(module.content.slice(start || void 0, end || void 0));
      }
    }
    for (const componentImport of componentExports) {
      const {start, end} = componentImport;
      state.exportStatements.add(module.content.slice(start || void 0, end || void 0));
    }
    if (componentProps.length > 0) {
      const shortname = path.posix.relative(compileOptions.astroConfig.projectRoot.pathname, state.filename);
      const props = componentProps.map((prop) => {
        var _a2;
        return (_a2 = prop.id) == null ? void 0 : _a2.name;
      }).filter((v) => v);
      warn(compileOptions.logging, shortname, yellow(`
Defining props with "export" has been removed! Please see https://github.com/snowpackjs/astro/blob/main/packages/astro/CHANGELOG.md#0150
Please update your code to use:

const { ${props.join(", ")} } = Astro.props;
`));
    }
    script = propsStatement + babelGenerator(program).code;
    const location = {start: module.start, end: module.end};
    let transpiledScript = transpileExpressionSafe(script, {state, compileOptions, location});
    if (transpiledScript === null)
      throw new Error(`Unable to compile script`);
    script = transpiledScript;
  }
  return {
    script,
    getStaticPaths: getStaticPaths || void 0
  };
}
function compileCss(style, state) {
  walk(style, {
    enter(node) {
      if (node.type === "Style") {
        state.css.push(node.content.styles);
        this.skip();
      }
    },
    leave(node) {
      if (node.type === "Style") {
        this.remove();
      }
    }
  });
}
function dedent(str) {
  var _a;
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let first = !!arr && ((_a = arr.find((x) => x.length > 0)) == null ? void 0 : _a.length);
  return !arr || !first ? str : str.replace(new RegExp(`^[ \\t]{0,${first}}`, "gm"), "");
}
const FALSY_EXPRESSIONS = new Set(["false", "null", "undefined", "void 0"]);
function isFrontmatterDefinedComponent(componentName, componentInfo, state) {
  let hasVariableDeclaration = state.declarations.has(componentName);
  let isNotImported = !componentInfo;
  return hasVariableDeclaration && isNotImported;
}
function isFragmentComponent(componentName) {
  return componentName === "Fragment";
}
async function compileHtml(enterNode, state, compileOptions) {
  return new Promise((resolve) => {
    const {components, css, importStatements, exportStatements, filename, fileID} = state;
    const {astroConfig} = compileOptions;
    let paren = -1;
    let buffers = {
      out: "",
      markdown: ""
    };
    let curr = "out";
    async function pushMarkdownToBuffer() {
      const md = buffers.markdown;
      const {markdownOptions = {}} = astroConfig;
      if (!md.trim()) {
        buffers.out += "," + md;
        buffers.markdown = "";
        curr = "out";
        return;
      }
      const {$scope: scopedClassName} = state.markers.insideMarkdown;
      let {content: rendered} = await renderMarkdown(dedent(md), __spreadProps(__spreadValues({}, markdownOptions), {
        $: {scopedClassName: scopedClassName && scopedClassName.slice(1, -1)}
      }));
      const ast = parse(rendered);
      await transform(ast, {
        compileOptions,
        filename,
        fileID
      });
      const result = await compileHtml(ast.html, __spreadProps(__spreadValues({}, state), {markers: {insideMarkdown: false}}), compileOptions);
      buffers.out += "," + result;
      buffers.markdown = "";
      curr = "out";
    }
    asyncWalk(enterNode, {
      async enter(node, parent) {
        switch (node.type) {
          case "Expression": {
            let code = await compileExpression(node, state, compileOptions);
            if (FALSY_EXPRESSIONS.has(code)) {
              this.skip();
              break;
            }
            if (code !== "") {
              if (state.markers.insideMarkdown) {
                buffers[curr] += `{${code}}`;
              } else {
                buffers[curr] += `,(${code})`;
              }
            }
            this.skip();
            break;
          }
          case "MustacheTag":
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
            }
            return;
          case "Comment":
            return;
          case "Fragment": {
            buffers[curr] += `h(Fragment, null,`;
            break;
          }
          case "SlotTemplate": {
            buffers[curr] += `h(Fragment, null, children`;
            paren++;
            return;
          }
          case "Slot":
          case "Head":
          case "InlineComponent": {
            switch (node.name) {
              case "Prism": {
                if (!importStatements.has(PRISM_IMPORT)) {
                  importStatements.add(PRISM_IMPORT);
                }
                if (!components.has("Prism")) {
                  components.set("Prism", {
                    importSpecifier: {
                      type: "ImportDefaultSpecifier",
                      local: {type: "Identifier", name: "Prism"}
                    },
                    url: "astro/components/Prism.astro"
                  });
                }
                break;
              }
            }
          }
          case "Title":
          case "Element": {
            const name = node.name;
            if (!name) {
              throw new Error("AHHHH");
            }
            try {
              const attributes = await getAttributes(name, node.attributes, state, compileOptions);
              const hydrationAttributes = findHydrationAttributes(attributes);
              buffers.out += buffers.out === "" ? "" : ",";
              if (node.type === "Slot") {
                state.importStatements.add(`import { __astro_slot } from 'astro/dist/internal/__astro_slot.js';`);
                buffers[curr] += `h(__astro_slot, ${generateAttributes(attributes)}, children`;
                paren++;
                return;
              }
              if (!isComponentTag(name)) {
                if (curr === "markdown") {
                  await pushMarkdownToBuffer();
                }
                if (attributes.slot) {
                  state.importStatements.add(`import { __astro_slot_content } from 'astro/dist/internal/__astro_slot.js';`);
                  buffers[curr] += `h(__astro_slot_content, { name: ${attributes.slot} },`;
                  paren++;
                }
                if (attributes.hoist) {
                  if (attributes.src) {
                    state.hoistedScripts.push({
                      src: attributes.src.substr(1, attributes.src.length - 2)
                    });
                  } else if (node.children && node.children.length === 1 && node.children[0].type === "Text") {
                    state.hoistedScripts.push({
                      content: node.children[0].data
                    });
                  }
                  this.skip();
                  return;
                }
                buffers[curr] += `h("${name}", ${generateAttributes(attributes)},`;
                paren++;
                return;
              }
              const [componentName, _componentKind] = name.split(":");
              let componentInfo = components.get(componentName);
              if (/\./.test(componentName)) {
                const [componentNamespace] = componentName.split(".");
                componentInfo = components.get(componentNamespace);
              }
              if (isFrontmatterDefinedComponent(componentName, componentInfo, state) && !isCustomElementTag(componentName) || isFragmentComponent(componentName)) {
                if (hydrationAttributes.method) {
                  throw new Error(`Unable to hydrate "${componentName}" because it is statically defined in the frontmatter script. Hydration directives may only be used on imported components.`);
                }
                if (curr === "markdown") {
                  await pushMarkdownToBuffer();
                }
                if (attributes.slot) {
                  state.importStatements.add(`import { __astro_slot_content } from 'astro/dist/internal/__astro_slot.js';`);
                  buffers[curr] += `h(__astro_slot_content, { name: ${attributes.slot} },`;
                  paren++;
                }
                buffers[curr] += `h(${componentName}, ${generateAttributes(attributes)},`;
                paren++;
                return;
              } else if (!componentInfo && !isCustomElementTag(componentName)) {
                throw new Error(`Unable to render "${componentName}" because it is undefined
  ${state.filename}`);
              }
              if (componentName === "Markdown") {
                const {$scope} = attributes != null ? attributes : {};
                state.markers.insideMarkdown = typeof state.markers.insideMarkdown === "object" ? {$scope, count: state.markers.insideMarkdown.count + 1} : {$scope, count: 1};
                const keys = Object.keys(attributes).filter((attr) => attr !== "$scope");
                if (keys.length > 0) {
                  if (curr === "markdown") {
                    await pushMarkdownToBuffer();
                  }
                  buffers[curr] += `,${componentName}.__render(${generateAttributes(attributes)}),`;
                }
                curr = "markdown";
                return;
              }
              const {wrapper, wrapperImports} = getComponentWrapper(name, hydrationAttributes, componentInfo != null ? componentInfo : {}, {astroConfig, filename, compileOptions});
              if (wrapperImports) {
                for (let wrapperImport of wrapperImports) {
                  importStatements.add(wrapperImport);
                }
              }
              if (hydrationAttributes.method === "only") {
                const componentImports = state.componentImports.get(componentName) || [];
                componentImports.map((componentImport) => state.importStatements.delete(componentImport));
              }
              if (curr === "markdown") {
                await pushMarkdownToBuffer();
              }
              if (attributes.slot) {
                state.importStatements.add(`import { __astro_slot_content } from 'astro/dist/internal/__astro_slot.js';`);
                buffers[curr] += `h(__astro_slot_content, { name: ${attributes.slot} },`;
                paren++;
              }
              paren++;
              buffers[curr] += `h(${wrapper}, ${generateAttributes(attributes)}`;
            } catch (err) {
              paren--;
              const rel = filename.replace(astroConfig.projectRoot.pathname, "");
              error(compileOptions.logging, rel, err.toString());
            }
            return;
          }
          case "Attribute":
          case "Spread": {
            this.skip();
            return;
          }
          case "Style": {
            css.push(node.content.styles);
            this.skip();
            return;
          }
          case "CodeSpan":
          case "CodeFence": {
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
              buffers[curr] += node.raw;
              return;
            }
            buffers[curr] += "," + JSON.stringify(node.data);
            return;
          }
          case "Text": {
            let text = getTextFromAttribute(node);
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
              buffers[curr] += text;
              return;
            }
            if (parent.name !== "Markdown" && !text.trim()) {
              return;
            }
            if (parent.name === "code") {
              text = node.raw.replace(/ASTRO_ESCAPED_LEFT_CURLY_BRACKET\0/g, "{");
            }
            buffers[curr] += "," + JSON.stringify(text);
            return;
          }
          default:
            throw new Error("Unexpected (enter) node type: " + node.type);
        }
      },
      async leave(node, parent, prop, index) {
        switch (node.type) {
          case "Fragment": {
            buffers[curr] += `)`;
            break;
          }
          case "Text":
          case "Attribute":
          case "Spread":
          case "Comment":
          case "Expression":
          case "MustacheTag":
          case "CodeSpan":
          case "CodeFence":
            return;
          case "SlotTemplate":
          case "Slot":
          case "Head":
          case "Body":
          case "Title":
          case "Element": {
            if (curr === "markdown") {
              await pushMarkdownToBuffer();
            }
            if (node.attributes.find((attr) => attr.name === "slot")) {
              buffers.out += ")";
              paren--;
            }
            if (paren !== -1) {
              buffers.out += ")";
              paren--;
            }
            return;
          }
          case "InlineComponent": {
            if (node.name === "Markdown") {
              state.markers.insideMarkdown.count--;
              if (state.markers.insideMarkdown.count <= 0) {
                state.markers.insideMarkdown = false;
              }
              const hasAttrs = node.attributes.filter(({name}) => name !== "$scope").length > 0;
              if (hasAttrs) {
                return;
              }
            }
            if (curr === "markdown" && buffers.markdown !== "") {
              await pushMarkdownToBuffer();
              if (!state.markers.insideMarkdown) {
                return;
              }
            }
            if (node.attributes.find((attr) => attr.name === "slot")) {
              buffers.out += ")";
              paren--;
            }
            if (paren !== -1) {
              buffers.out += ")";
              paren--;
            }
            return;
          }
          case "Style": {
            this.remove();
            return;
          }
          default:
            throw new Error("Unexpected (leave) node type: " + node.type);
        }
      }
    }).then(() => {
      const content = buffers.out.replace(/^\,/, "").replace(/\,\)/g, ")").replace(/\,+/g, ",").replace(/\)h/g, "),h");
      buffers.out = "";
      buffers.markdown = "";
      return resolve(content);
    });
  });
}
async function codegen(ast, {compileOptions, filename, fileID}) {
  await eslexer.init;
  const state = {
    filename,
    fileID,
    components: new Map(),
    css: [],
    hoistedScripts: [],
    markers: {
      insideMarkdown: false
    },
    declarations: new Set(),
    importStatements: new Set(),
    exportStatements: new Set(),
    componentImports: new Map(),
    customElementCandidates: new Map()
  };
  const {script, getStaticPaths} = compileModule(ast, ast.module, state, compileOptions);
  (ast.css || []).map((css) => compileCss(css, state));
  const html = await compileHtml(ast.html, state, compileOptions);
  return {
    script,
    imports: Array.from(state.importStatements),
    exports: Array.from(state.exportStatements),
    html,
    css: state.css.length ? state.css.join("\n\n") : void 0,
    hoistedScripts: state.hoistedScripts,
    components: Array.from(state.components.keys()),
    getStaticPaths,
    hasCustomElements: Boolean(ast.meta.features & FEATURE_CUSTOM_ELEMENT),
    customElementCandidates: state.customElementCandidates
  };
}
export {
  codegen
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL2NvbXBpbGVyL2NvZGVnZW4vaW5kZXgudHMiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU0sQ0FBRSxPQUFPLDBCQUEyQjtBQUMxQyxNQUFNLFdBQTBDLGNBQWMsUUFBZ0I7QUFHOUUsTUFBTSxpQkFBeUMsZ0JBQWdCO0FBQy9ELE1BQU0sQ0FBRSxpQkFBa0I7QUFFMUIsTUFBTSxzQkFBc0IsSUFBSSxJQUFJLENBQUMsZUFBZSxlQUFlLGtCQUFrQixnQkFBZ0I7QUFjckcsaUNBQWlDLE9BQW9EO0FBQ25GLE1BQUk7QUFDSixNQUFJO0FBRUosYUFBVyxDQUFDLEtBQUssUUFBUSxPQUFPLFFBQVEsUUFBUTtBQUM5QyxRQUFJLG9CQUFvQixJQUFJLE1BQU07QUFDaEMsZUFBUyxJQUFJLE1BQU07QUFDbkIsY0FBUSxRQUFRLFNBQVMsU0FBWTtBQUFBO0FBQUE7QUFJekMsU0FBTyxDQUFFLFFBQVE7QUFBQTtBQUluQiw2QkFBNkIsVUFBa0IsT0FBb0IsT0FBcUIsZ0JBQWlFO0FBQ3ZKLFFBQU0sU0FBUyxNQUFNLFNBQVMsV0FBVyxjQUFjLGVBQWUsWUFBWTtBQUNsRixNQUFJLFNBQWlDO0FBQ3JDLGFBQVcsUUFBUSxPQUFPO0FBQ3hCLFFBQUksS0FBSyxTQUFTLFVBQVU7QUFDMUIsWUFBTSxPQUFPLE1BQU0sa0JBQWtCLEtBQUssWUFBMEIsT0FBTztBQUMzRSxVQUFJLE1BQU07QUFDUixlQUFPLE9BQU8sV0FBVztBQUFBO0FBRTNCO0FBQUE7QUFFRixRQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLGFBQU8sS0FBSyxRQUFRLEtBQUssVUFBVSxLQUFLO0FBQ3hDO0FBQUE7QUFFRixRQUFJLEtBQUssVUFBVSxTQUFT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
